#!/usr/bin/env perl

use strict;
use warnings;
use IO::Socket::UNIX;
use FindBin qw($Bin);
use lib "$Bin/../local/lib/perl5";
use Mojo::File qw(path);
use Mojo::Util qw(trim);
use Sereal::Decoder;
use Sereal::Encoder;

$SIG{CHLD} = 'IGNORE';

die "$0 must be run as root" unless $> == 0;
die "BLIPTOWN_HELPER_SOCKET not defined" unless $ENV{BLIPTOWN_HELPER_SOCKET};
die "BLIPTOWN_USER_HOME not defined" unless $ENV{BLIPTOWN_USER_HOME};
die "BLIPTOWN_KEYPAIR_FILE not defined "unless $ENV{BLIPTOWN_KEYPAIR_FILE};
die "BLIPTOWN_ACME_FILE not defined" unless $ENV{BLIPTOWN_ACME_FILE};

my $sock_path = $ENV{BLIPTOWN_HELPER_SOCKET};
unlink $sock_path if -e $sock_path;

my $server = IO::Socket::UNIX->new(
	Type => SOCK_STREAM,
	Local => $sock_path,
	Listen => 5,
) or die "Cannot create socket: $sock_path ($!)";

my $gid = getgrnam('bliptown') or die "Cannot get gid: bliptown ($!)";
chown(0, $gid, $sock_path) or die "Cannot chown: $sock_path ($!)";
chmod(0660, $sock_path) or die "Cannot chmod: $sock_path ($!)";

print "Socket created: $sock_path\n";

sub provision_cert {
	my $payload = shift;
	my $domain = $payload->{domain};
	return unless $domain;
	my $pid = fork();
	if ($pid == 0) {
		exec('acme-client', $domain);
	}
}

sub update_domain_list {
	my $payload = shift;
	my $all_domains = $payload->{all_domains};
	my $keypair_file = path($ENV{BLIPTOWN_KEYPAIR_FILE});
	$keypair_file->touch unless -f $keypair_file;
	my $acme_file = path($ENV{BLIPTOWN_ACME_FILE});
	$acme_file->touch unless -f $acme_file;

	my $keypairs_str;
	foreach (@$all_domains) {
		$keypairs_str .= "tls keypair \"$_\"\n";
	}

	my $keypair_file_str = $keypair_file->slurp('utf-8');

	unless ($keypairs_str eq $keypair_file_str) {
		$keypair_file->spew($keypairs_str, 'utf-8')
			or die "Cannot write keypair file: $keypair_file ($!)";

		my $pid = fork();
		if ($pid == 0) {
			exec('rcctl', 'reload', 'relayd');
		}
	}

	my $acme_domains_str;
	foreach (@$all_domains) {
		$acme_domains_str .= <<"EOF";
domain $_ {
	alternative names { www.$_ }
	domain certificate "/etc/ssl/$_.crt"
	domain key "/etc/ssl/private/$_.key"
	sign with "letsencrypt"
}
EOF
	}

	my $acme_file_str = $acme_file->slurp('utf-8');

	unless ($acme_domains_str eq $acme_file_str) {
		$acme_file->spew($acme_domains_str, 'utf-8');
	}
	
	my $pid = fork();
	if ($pid == 0) {
		exec('rcctl', 'reload', 'relayd');
	}
}

sub get_uid_gid {
	my $username = shift;
	my @pw = getpwnam($username) or die "Cannot find user: $username";
	my $uid = $pw[2];
	my $gid = $pw[3];
	return ($uid, $gid);
}

sub delete_empty_dirs {
	my $username = shift;
	my $root = path($ENV{BLIPTOWN_USER_HOME}, $username);
	$root = $root->realpath;
	foreach ($root->list_tree({ dir => 1 })->each) {
		next unless -d $_;
		rmdir $_;
	}
}

sub write_blob {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $blob = $payload->{blob};
	my $path = path($filename);
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";;
	$path->spew($blob) or die "Cannot write file: $path ($!)";
}

sub update_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $content = $payload->{content};
	my $path = path($filename);
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	if ($payload->{create_backup} && -e $filename) {
		rename $filename, "${filename}~"
			or die "Cannot create backup: $filename~ ($!)"
	}
	$path->spew($content, 'utf-8') or die "Cannot write file: $path ($!)";
}

sub rename_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path($filename);
	my $new_filename = $payload->{new_filename};
	my $new_path = path($new_filename);
	my $dir = $new_path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	$path->move_to($new_path) or die "Cannot move file: $path ($!)";
}

sub delete_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path($filename);
	$path->remove or die "Cannot delete file: $filename ($!)";
}

sub git_init {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $excludes_file = '/etc/gitignore';
	chdir $repo or die "Cannot change directory: $repo ($!)";

	die "Cannot initialize repository: $repo"
		unless system('git init --quiet');
	die "Cannot configure repository ignore file"
		unless system("git config set core.excludesFile $excludes_file");
	return 1;
}

sub git_log {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	my $out = `git log --date=format:"%Y-%m-%d %H:%M %z" --pretty=format:"%h%x00%s%x00%ad%x00%b%x01" --max-count=50`;

	my @commits;
	foreach (split /\x01/, $out) {
		my $commit = trim($_);
		my ($hash, $subject, $date, $body) = split /\x00/, $commit, 4;
		push @commits, {
			hash => $hash,
			subject => $subject,
			date => $date,
			body => $body,
		};
	}
	return \@commits;
}

sub git_commit {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";

	die "Cannot add files to $repo" unless system('git add -A');

	my $subject = 'Full snapshot on blip.town';
	my $body = `git status --porcelain`;
	die "No changes to commit" unless (length($body));

	die "Cannot commit files to repo: $repo ($!)"
		unless system("git commit -m '$subject' -m '$body'");

	my $commits = git_log($payload);
	my $hash = $commits->[0]->{hash};
	return $hash;
}

sub git_checkout {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $hash = $payload->{hash};
	my $dir = path($repo, 'snapshots', $hash);
	$dir->make_path or die "Cannot make path: $dir ($!)";
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	die "Failed to extract archive from hash: $hash"
		unless system("git archive '$hash' | tar -x -C '$dir'");
	return $hash;
}

my %allowed_commands = (
	write_blob			=> \&write_blob,
	update_file			=> \&update_file,
	rename_file			=> \&rename_file,
	delete_file			=> \&delete_file,
	git_commit			=> \&git_commit,
	git_log				=> \&git_log,
	git_checkout		=> \&git_checkout,
	provision_cert		=> \&provision_cert,
	update_domain_list	=> \&update_domain_list,
);

my $decoder = Sereal::Decoder->new;
my $encoder = Sereal::Encoder->new;

while (my $conn = $server->accept()) {
	my $req_blob;
	while (read($conn, my $buf, 512)) {
		$req_blob .= $buf;
	}

	my $data = $decoder->decode($req_blob);
	my $command = $data->{command};
	my $payload = $data->{payload};
	my $res;
	eval {
		my $username = $payload->{username};

		unless ($username eq 'root') {
			my ($uid, $gid) = get_uid_gid($username);

			die "Cannot set group: $gid ($!)" unless $) = "$gid $gid";
			die "Cannot set user: $uid ($!)" unless $> = $uid;
		}

		my $func = $allowed_commands{$command} or
			die "Command not permitted: $command";
		$res = $func->($payload);
		delete_empty_dirs($username);
	};
	my $err = $@;

	$> = 0;
	$) = 0;

	my $res_blob = $encoder->encode(
		{
			response => $res,
			error => $err,
		});
	$conn->send($res_blob) or warn "Cannot send response ($!)";
	close($conn);
}
