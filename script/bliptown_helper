#!/usr/bin/env perl

use strict;
use warnings;
use IO::Socket::UNIX;
use FindBin qw($Bin);
use lib "$Bin/../local/lib/perl5";
use POSIX qw(setgid setuid pause WNOHANG);
use Mojo::File qw(path tempfile);
use Mojo::Util qw(trim);
use Sereal::Decoder;
use Sereal::Encoder;

die "$0 must be run as root" unless $> == 0;
die "BLIPTOWN_HELPER_SOCKET not defined" unless $ENV{BLIPTOWN_HELPER_SOCKET};
die "BLIPTOWN_HELPER_PREFORK not defined" unless $ENV{BLIPTOWN_HELPER_PREFORK};
die "BLIPTOWN_USER_HOME not defined" unless $ENV{BLIPTOWN_USER_HOME};
die "BLIPTOWN_KEYPAIR_FILE not defined "unless $ENV{BLIPTOWN_KEYPAIR_FILE};
die "BLIPTOWN_ACME_FILE not defined" unless $ENV{BLIPTOWN_ACME_FILE};

my $prefork = $ENV{BLIPTOWN_HELPER_PREFORK} // 4;
my %children;

my $sock_path = $ENV{BLIPTOWN_HELPER_SOCKET};
unlink $sock_path if -e $sock_path;

my $sock = IO::Socket::UNIX->new(
	Type => SOCK_STREAM,
	Local => $sock_path,
	Listen => 128,
) or die "Cannot create socket: $sock_path ($!)";

my $gid = getgrnam('bliptown') or die "Cannot get gid: bliptown ($!)";
chown(0, $gid, $sock_path) or die "Cannot chown: $sock_path ($!)";
chmod(0660, $sock_path) or die "Cannot chmod: $sock_path ($!)";

print "Socket created: $sock_path\n";

sub provision_cert {
	my $payload = shift;
	my $domain = $payload->{domain};
	return unless $domain;
	system('acme-client', $domain);
	return "Provisioned certificate: $domain";
}

sub update_domain_list {
	my $payload = shift;
	my $all_domains = $payload->{all_domains};
	my $keypair_file = path($ENV{BLIPTOWN_KEYPAIR_FILE});
	$keypair_file->touch unless -f $keypair_file;
	my $acme_file = path($ENV{BLIPTOWN_ACME_FILE});
	$acme_file->touch unless -f $acme_file;

	my $keypairs_str;
	foreach (@$all_domains) {
		$keypairs_str .= "tls keypair \"$_\"\n";
	}

	my $keypair_file_str = $keypair_file->slurp('utf-8');

	unless ($keypairs_str eq $keypair_file_str) {
		$keypair_file->spew($keypairs_str, 'utf-8')
			or die "Cannot write keypair file: $keypair_file ($!)";

		system('rcctl', 'reload', 'relayd');
	}

	my $acme_domains_str;
	foreach (@$all_domains) {
		$acme_domains_str .= <<"EOF";
domain $_ {
	alternative names { www.$_ }
	domain certificate "/etc/ssl/$_.crt"
	domain key "/etc/ssl/private/$_.key"
	sign with "letsencrypt"
}
EOF
	}

	my $acme_file_str = $acme_file->slurp('utf-8');

	unless ($acme_domains_str eq $acme_file_str) {
		$acme_file->spew($acme_domains_str, 'utf-8');
	}
	return "Domain list up-to-date";
}

sub get_uid_gid {
	my $username = shift;
	my @pw = getpwnam($username) or die "Cannot find user: $username";
	my $uid = $pw[2];
	my $gid = $pw[3];
	return ($uid, $gid);
}

sub delete_empty_dirs {
	my $username = shift;
	my $root = path($ENV{BLIPTOWN_USER_HOME}, $username);
	$root = $root->realpath;
	foreach ($root->list_tree({ dir => 1 })->each) {
		next unless -d $_;
		rmdir $_;
	}
}

sub write_blob {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $blob = $payload->{blob};
	my $path = path($filename);
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";;
	$path->spew($blob) or die "Cannot write file: $path ($!)";
	return "Wrote file: $filename";
}

sub update_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $content = $payload->{content};
	my $path = path($filename);
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	if ($payload->{create_backup} && -e $filename) {
		rename $filename, "${filename}~"
			or die "Cannot create backup: $filename~ ($!)"
	}
	$path->spew($content, 'utf-8') or die "Cannot write file: $path ($!)";
	return "Updated file: $filename"
}

sub rename_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path($filename);
	my $new_filename = $payload->{new_filename};
	my $new_path = path($new_filename);
	my $dir = $new_path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	$path->move_to($new_path) or die "Cannot move file: $path ($!)";
	return "Renamed file: $filename -> $new_filename"
}

sub delete_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path($filename);
	$path->remove or die "Cannot delete file: $filename ($!)";
	return "Deleted file: $filename"
}

sub git_init {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $excludes_file = '/etc/gitignore';
	chdir $repo or die "Cannot change directory: $repo ($!)";

	system('git init --quiet') == 0
		or die "Cannot initialize repository: $repo ($!)";
	system("git config set core.excludesFile $excludes_file") == 0
		or die "Cannot configure repository ignore file ($!)";
	return "Initialized Git repository: $repo";
}

sub git_log {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	my $out = `git log --date=format:"%Y-%m-%d %H:%M %z" --pretty=format:"%h%x00%s%x00%ad%x00%b%x01" --max-count=50`;

	my @commits;
	foreach (split /\x01/, $out) {
		my $commit = trim($_);
		my ($hash, $subject, $date, $body) = split /\x00/, $commit, 4;
		push @commits, {
			hash => $hash,
			subject => $subject,
			date => $date,
			body => $body,
		};
	}
	return \@commits;
}

sub git_commit {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";

	system('git add -A') == 0
		or die "Cannot add files to $repo";

	my $subject = 'Full snapshot on blip.town';
	my $body = `git status --porcelain`;
	die "No changes to commit" unless (length($body));

	system("git commit -m '$subject' -m '$body'") == 0
		or die "Cannot commit files to repo: $repo ($!)";

	my $commits = git_log($payload);
	my $hash = $commits->[0]->{hash};
	return $hash;
}

sub git_checkout {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $hash = $payload->{hash};
	my $dir = path($repo, 'snapshots', $hash);
	$dir->make_path or die "Cannot make path: $dir ($!)";
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	system("git archive '$hash' | tar -xf - -C '$dir'") == 0
		or die "Failed to extract archive from hash: $hash";
	return $hash;
}

sub git_archive {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $hash = $payload->{hash};
	my $tmpfile = tempfile(UNLINK => 0);
	chmod(0644, $tmpfile);
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	system("git archive --format=tar.gz '$hash' > $tmpfile") == 0
		or die "Failed to extract archive from hash: $hash";
	return $tmpfile->to_string;
}

my %allowed_commands = (
	write_blob			=> \&write_blob,
	update_file			=> \&update_file,
	rename_file			=> \&rename_file,
	delete_file			=> \&delete_file,
	git_commit			=> \&git_commit,
	git_log				=> \&git_log,
	git_checkout		=> \&git_checkout,
	git_archive			=> \&git_archive,
	provision_cert		=> \&provision_cert,
	update_domain_list	=> \&update_domain_list,
);

my $decoder = Sereal::Decoder->new;
my $encoder = Sereal::Encoder->new;

sub handle_conn {
	my $conn = shift;

	my $req_blob;
	while (read($conn, my $buf, 512)) {
		$req_blob .= $buf;
	}

	my $data = $decoder->decode($req_blob);
	my $command = $data->{command};
	my $payload = $data->{payload};

	my ($res, $err);

	eval {
		my $username = $payload->{username};

		unless ($username eq 'root') {
			my ($uid, $gid) = get_uid_gid($username);

			setgid($gid) == 0 or die "Cannot set group: $gid ($!)";
			setuid($uid) == 0 or die "Cannot set user: $uid ($!)";
		}

		my $func = $allowed_commands{$command} or
			die "Command not permitted: $command";

		$res = $func->($payload);
		delete_empty_dirs($username);
	};
	$err = $@;

	my $res_blob = $encoder->encode(
		{
			response => $res,
			error => $err,
		});

	$conn->send($res_blob) or warn "Cannot send response ($!)";
	return;
}

sub spawn_worker {
	my $pid = fork();
	die "Cannot fork process ($!)" unless defined $pid;

	if ($pid == 0) {
		while (1) {
			my $conn = $sock->accept();
			next unless $conn;

			handle_conn($conn);
			close $conn;
			last;
		}
		exit 0;
	}

	$children{$pid} = 1;
}

$SIG{CHLD} = sub {
	while ((my $pid = waitpid(-1, WNOHANG)) > 0) {
		delete $children{$pid};
	}
};

for (1 .. $prefork) {
	spawn_worker();
}

while (1) {
	while (keys(%children) < $prefork) {
		spawn_worker();
	}
	pause();
}
