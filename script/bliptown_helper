#!/usr/bin/env perl

use strict;
use warnings;
use Cwd qw(abs_path);
use IO::Socket::UNIX;
use Storable qw(fd_retrieve);

die "$0 must be run as root" unless $> == 0;
die "BLIPTOWN_USER_HOME not defined" unless $ENV{BLIPTOWN_USER_HOME};

my $sock_path = '/tmp/bliptown_helper.sock';
unlink $sock_path if -e $sock_path;

my $server = IO::Socket::UNIX->new(
	Type => SOCK_STREAM,
	Local => $sock_path,
	Listen => 5,
) or die "Cannot create socket: $sock_path ($!)";

my $gid = getgrnam('_bliptown') || die "Cannot get gid: _bliptown ($!)";
chown(0, $gid, $sock_path) || die "Cannot chown: $sock_path ($!)";
chmod(0660, $sock_path) || die "Cannot chmod: $sock_path ($!)";

print "Socket created: $sock_path\n";

sub get_uid_gid {
	my $user = shift;
	my $uid = getpwnam($user) || die "Cannot get uid: $user ($!)";
	my $gid = getgrnam($user) || die "Cannot get gid: $user ($!)";
	return ($uid, $gid);
}

sub safe_file {
	my ($user, $file) = @_;
	die "Invalid username: $user" unless $user =~ /^[a-zA-Z0-9-_]+$/;
	my $sandbox = $ENV{BLIPTOWN_USER_HOME} . '/' . $user;
	my $file_abs = abs_path($file) || die "Cannot get file: $file ($!)";
	die "File outside of sandbox: $file_abs ($!)"
		unless $file_abs =~ /^\Q$sandbox\E/;
	return $file_abs;
}

sub update_file {
	my $payload = shift;
	my $user = $payload->{user};
	my $file = $payload->{file};
	my $content = $payload->{content};
	my $safe_file = safe_file($user, $file);
	if (open(my $fh, '>', $safe_file)) {
		print $fh $content;
		close $fh;
	} else {
		die "Cannot open file: $file ($!)";
	}
	my ($uid, $gid) = get_uid_gid($user);
	chown($uid, $gid, $safe_file) ||
		die "Cannot set ownership: $file ($!)";
	chmod(0644, $safe_file) ||
		die "Cannot set permissions: $file ($!)";
}

sub rename_file {
	my $payload = shift;
	my $user = $payload->{user};
	my $file = $payload->{file};
	my $new_name = $payload->{new_name};
	my $safe_file = safe_file($user, $file);
	my $safe_new_name = safe_file($user, $new_name);
	rename($safe_file, $safe_new_name) if -f $safe_file ||
		die "Cannot rename file: $file ($!)";
}

sub delete_file {
	my $payload = shift;
	my $user = $payload->{user};
	my $file = $payload->{file};
	my $safe_file = safe_file($user, $file);
	unlink $safe_file if -f $safe_file ||
		die "Cannot delete file: $file ($!)";
}

my %allowed_commands = (
	update_file => \&update_file,
	rename_file => \&rename_file,
	delete_file => \&delete_file,
);

while (my $conn = $server->accept()) {
    my $req = fd_retrieve($conn) ||
		die "Cannot read socket ($!)";
	my $command = $req->{command};
	my $payload = $req->{payload};
	my $success = eval {
		my $func = $allowed_commands{$command} ||
			die "Command not permitted: $command ($!)";

		$func->($payload);
		return 1;
	};

	unless ($success) { warn }

    close($conn);
}
