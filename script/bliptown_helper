#!/usr/bin/env perl

use strict;
use warnings;
use IO::Socket::UNIX;
use FindBin qw($Bin);
use lib "$Bin/../local/lib/perl5";
use Mojo::File qw(path);
use Sereal::Decoder;

$SIG{CHLD} = 'IGNORE';

die "$0 must be run as root" unless $> == 0;
die "BLIPTOWN_HELPER_SOCKET not defined" unless $ENV{BLIPTOWN_HELPER_SOCKET};
die "BLIPTOWN_USER_HOME not defined" unless $ENV{BLIPTOWN_USER_HOME};
die "BLIPTOWN_KEYPAIR_FILE not defined "unless $ENV{BLIPTOWN_KEYPAIR_FILE};
die "BLIPTOWN_ACME_FILE not defined" unless $ENV{BLIPTOWN_ACME_FILE};

my $sock_path = $ENV{BLIPTOWN_HELPER_SOCKET};
unlink $sock_path if -e $sock_path;

my $server = IO::Socket::UNIX->new(
	Type => SOCK_STREAM,
	Local => $sock_path,
	Listen => 5,
) or die "Cannot create socket: $sock_path ($!)";

my $gid = getgrnam('_bliptown') or die "Cannot get gid: _bliptown ($!)";
chown(0, $gid, $sock_path) or die "Cannot chown: $sock_path ($!)";
chmod(0660, $sock_path) or die "Cannot chmod: $sock_path ($!)";

print "Socket created: $sock_path\n";

sub provision_cert {
	my $payload = shift;
	my $domain = $payload->{domain};
	return unless $domain;
	my $pid = fork();
	if ($pid == 0) {
		exec('acme-client', $domain);
	}
}

sub update_domain_list {
	my $payload = shift;
	my $all_domains = $payload->{all_domains};
	my $keypair_file = $ENV{BLIPTOWN_KEYPAIR_FILE};
	my $acme_file = $ENV{BLIPTOWN_ACME_FILE};

	if (open(my $fh, '>', $keypair_file)) {
		foreach my $domain (@$all_domains) {
			print $fh "tls keypair \"$domain\"\n";
		}
		close $fh or die "Cannot close keypair file: $keypair_file ($!)";
	} else { die "Cannot open keypair file: $keypair_file ($!)"; }

	if (open(my $fh, '>', $acme_file)) {
		foreach my $domain (@$all_domains) {
			print $fh <<"EOF";
domain $domain {
	alternative names { www.$domain }
	domain certificate "/etc/ssl/$domain.crt"
	domain key "/etc/ssl/private/$domain.key"
	sign with "letsencrypt"
}
EOF
		}
		close $fh or die "Cannot close acme-client file: $acme_file ($!)";
	} else { die "Cannot open acme-client file: $acme_file ($!)" }
	
	my $pid = fork();
	if ($pid == 0) {
		exec('rcctl', 'reload', 'relayd');
	}
}

sub get_uid_gid {
	my $username = shift;
	my @pw = getpwnam($username) or die "Cannot find user: $username";
	my $uid = $pw[2];
	my $gid = $pw[3];
	return ($uid, $gid);
}

sub delete_empty_dirs {
	my $username = shift;
	my $root = path($ENV{BLIPTOWN_USER_HOME}, $username);
	$root = $root->realpath;
	foreach ($root->list_tree({ dir => 1 })->each) {
		next unless -d $_;
		rmdir $_;
	}
}

sub write_blob {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $blob = $payload->{blob};
	my $path = path($filename);
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";;
	$path->spew($blob) or die "Cannot write file: $path ($!)";
}

sub update_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $content = $payload->{content};
	my $path = path($filename);
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	if ($payload->{create_backup} && -e $filename) {
		rename $filename, "${filename}~"
			or die "Cannot create backup: $filename~ ($!)"
	}
	$path->spew($content, 'UTF-8') or die "Cannot write file: $path ($!)";
}

sub rename_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path($filename);
	my $new_filename = $payload->{new_filename};
	my $new_path = path($new_filename);
	my $dir = $new_path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	$path->move_to($new_path) or die "Cannot move file: $path ($!)";
}

sub delete_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path($filename);
	$path->remove or die "Cannot delete file: $filename ($!)";
}

my %allowed_commands = (
	write_blob  => \&write_blob,
	update_file => \&update_file,
	rename_file => \&rename_file,
	delete_file => \&delete_file,
	provision_cert => \&provision_cert,
	update_domain_list => \&update_domain_list,
);

my $decoder = Sereal::Decoder->new;

while (my $conn = $server->accept()) {

	my $blob;
	while (read($conn, my $buf, 1024)) {
		$blob .= $buf;
	}

	my $data = $decoder->decode($blob);
	my $command = $data->{command};
	my $payload = $data->{payload};
	my $ok = eval {
		my $username = $payload->{username};
		my ($uid, $gid) = get_uid_gid($username);

		$) = "$gid $gid" or die "Cannot set group: $gid";
		$> = $uid or die "Cannot set user: $uid";

		my $func = $allowed_commands{$command} or
			die "Command not permitted: $command";
		$func->($payload);

		delete_empty_dirs($username);

		return 1;
	};
	$> = 0;
	$) = 0;
	warn unless $ok;

	close($conn);
}
