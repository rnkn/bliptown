#!/usr/bin/env perl

use strict;
use warnings;
use IO::Socket::UNIX;
use FindBin qw($Bin);
use lib "$Bin/../local/lib/perl5";
use POSIX qw(setgid setuid pause WNOHANG);
use Mojo::File qw(path tempfile);
use Mojo::Util qw(trim);
use Sereal::Decoder;
use Sereal::Encoder;

my $has_unveil = eval {
	require OpenBSD::Unveil;
	OpenBSD::Unveil->import();
	return 1;
};

$0 = $0 . '[master]';

die "$0 must be run as root" unless $> == 0;

die "BLIPTOWN_HELPER_SOCKET not defined" unless $ENV{BLIPTOWN_HELPER_SOCKET};
die "BLIPTOWN_HELPER_PREFORK not defined" unless $ENV{BLIPTOWN_HELPER_PREFORK};
die "BLIPTOWN_HELPER_HEALTH_FILE not defined" unless $ENV{BLIPTOWN_HELPER_HEALTH_FILE};

die "BLIPTOWN_GID not defined" unless $ENV{BLIPTOWN_GID};
die "BLIPTOWN_USER_HOME not defined" unless $ENV{BLIPTOWN_USER_HOME};

die "BLIPTOWN_KEYPAIR_FILE not defined "unless $ENV{BLIPTOWN_KEYPAIR_FILE};
die "BLIPTOWN_ACME_FILE not defined" unless $ENV{BLIPTOWN_ACME_FILE};

my $prefork = $ENV{BLIPTOWN_HELPER_PREFORK} // 4;
my %children;
my $needs_reap;
my $shutdown;

my $health_file = path($ENV{BLIPTOWN_HELPER_HEALTH_FILE});
$health_file->remove->touch or die "Cannot create health file: $health_file\n";
print "Health file created: $health_file\n";

my $sock_path = $ENV{BLIPTOWN_HELPER_SOCKET};
unlink $sock_path if -e $sock_path;

my $sock = IO::Socket::UNIX->new(
	Type => SOCK_STREAM,
	Local => $sock_path,
	Listen => 128,
) or die "Cannot create socket: $sock_path ($!)";

chown(0, $ENV{BLIPTOWN_GID}, $sock_path) or die "Cannot chown: $sock_path ($!)";
chmod(0660, $sock_path) or die "Cannot chmod: $sock_path ($!)";

print "Socket created: $sock_path\n";

my $safe_domain_regex = qr/^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/;
my $safe_hash_regex = qr/^[0-9a-f]{7,40}$/;

sub provision_cert {
	my $payload = shift;
	my $domain = $payload->{domain};
	return unless $domain =~ $safe_domain_regex;
	system('acme-client', $domain);
	return "Provisioned certificate: $domain";
}

sub update_domain_list {
	my $payload = shift;
	my $domains = $payload->{domains};

	my $keypair_file = path($ENV{BLIPTOWN_KEYPAIR_FILE});
	my $acme_file = path($ENV{BLIPTOWN_ACME_FILE});

	if ($has_unveil) {
		my @paths = ($keypair_file, $acme_file);
		unveil(\@paths, "rwc");
		unveil();
	}

	$keypair_file->touch unless -f $keypair_file;
	$acme_file->touch unless -f $acme_file;

	my @safe_domains = grep { /$safe_domain_regex/ } @$domains;

	my $keypairs_str = '';
	foreach my $domain (@safe_domains) {
		$keypairs_str .= "tls keypair \"$domain\"\n";
	}

	my $keypair_file_str = $keypair_file->slurp('utf-8');
	unless ($keypairs_str eq $keypair_file_str) {
		$keypair_file->spew($keypairs_str, 'utf-8')
			or die "Cannot write keypair file: $keypair_file ($!)";

		system(qw(rcctl restart relayd));
	}

	my $acme_domains_str = '';
	foreach my $domain (@safe_domains) {
		$acme_domains_str .= <<"EOF";
domain $domain {
	alternative names { www.$domain }
	domain certificate "/etc/ssl/$domain.crt"
	domain key "/etc/ssl/private/$domain.key"
	sign with "letsencrypt"
}
EOF
	}

	my $acme_file_str = $acme_file->slurp('utf-8');
	unless ($acme_domains_str eq $acme_file_str) {
		$acme_file->spew($acme_domains_str, 'utf-8');
	}
	return "Domain list up-to-date";
}

sub get_uid_gid {
	my $username = shift;
	my @pw = getpwnam($username) or die "Cannot find user: $username";
	my $uid = $pw[2];
	my $gid = $pw[3];
	return ($uid, $gid);
}

sub delete_empty_dirs {
	my $username = shift;
	my $root = path($ENV{BLIPTOWN_USER_HOME}, $username);
	foreach my $dir (@{$root->list_tree({ dir => 1 })}) {
		next unless -d $dir;
		rmdir $dir;
	}
}

sub write_blob {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $blob = $payload->{blob};
	my $path = path $filename;
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";;
	$path->spew($blob) or die "Cannot write file: $path ($!)";
	return "Wrote file: $filename";
}

sub backup_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path $filename;
	$path->copy_to("${filename}~") or die "Cannot backup file: $path ($!)";
	return "Created backup file: ${filename}~"
}

sub update_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $content = $payload->{content};
	my $path = path $filename;
	my $dir = $path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	if ($payload->{create_backup} && -e $filename) {
		backup_file $payload;
	}
	$path->spew($content, 'utf-8') or die "Cannot write file: $path ($!)";
	return "Updated file: $filename"
}

sub rename_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path $filename;
	my $new_filename = $payload->{new_filename};
	my $new_path = path $new_filename;
	my $dir = $new_path->dirname;
	$dir->make_path or die "Cannot creat path: $dir ($!)";
	$path->move_to($new_path) or die "Cannot move file: $path ($!)";
	return "Renamed file: $filename -> $new_filename"
}

sub delete_file {
	my $payload = shift;
	my $filename = $payload->{filename};
	my $path = path $filename;
	$path->remove or die "Cannot delete file: $filename ($!)";
	return "Deleted file: $filename"
}

sub git_init {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $excludes_file = '/etc/gitignore';
	chdir $repo or die "Cannot change directory: $repo ($!)";

	system(qw(git init -q)) == 0
		or die "Cannot initialize repository: $repo ($!)";
	system('git', 'config', 'set', 'user.name', $username) == 0
		or die "Cannot configure repository user name ($!)";
	system('git', 'config', 'set', 'user.email', "${username}\@blip.town") == 0
		or die "Cannot configure repository user email ($!)";
	system('git', 'config', 'set', 'core.excludesFile', $excludes_file) == 0
		or die "Cannot configure repository ignore file ($!)";
	return "Initialized Git repository: $repo";
}

sub git_log {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	my $out = `git log --date=format:"%Y-%m-%d %H:%M %z" --pretty=format:"%h%x00%s%x00%ad%x00%b%x01" --max-count=50`;

	my @commits;
	foreach my $commit (split /\x01/, $out) {
		my $commit = trim $commit;
		my ($hash, $subject, $date, $body) = split(/\x00/, $commit, 4);
		push @commits, {
			hash => $hash,
			subject => $subject,
			date => $date,
			body => $body,
		};
	}
	return \@commits;
}

sub git_show {
	my $payload = shift;
	my $username = $payload->{username};
	my $hash = $payload->{hash};
	die "Invalid hash: $hash" unless $hash =~ $safe_hash_regex;
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	my $out = `git show $hash`;
	return unless length $out;
	return $out;
}

sub git_commit {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";

	system(qw(git add -A)) == 0
		or die "Cannot add files to $repo";

	my $subject = "Full snapshot on Bliptown";
	my $body = `git status --porcelain`;
	return unless length $body;

	system('git', 'commit', '-q', '-m', $subject, '-m', $body) == 0
		or die "Cannot commit files to repo: $repo ($!)";

	my $commits = git_log($payload);
	my $hash = $commits->[0]->{hash};
	return $hash;
}

sub git_checkout {
	my $payload = shift;
	my $username = $payload->{username};
	my $root = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $hash = $payload->{hash};
	die "Invalid hash: $hash" unless $hash =~ $safe_hash_regex;
	my $dir = path($root, 'snapshots', $hash);
	$dir->make_path or die "Cannot make path: $dir ($!)";
	my $tarball = git_archive($payload);
	system('tar', '-xzf', $tarball, '-C', $dir) == 0
		or die "Failed to extract files from tarball ($!)";
	unlink $tarball;
	return $hash;
}

sub git_archive {
	my $payload = shift;
	my $username = $payload->{username};
	my $repo = path($ENV{BLIPTOWN_USER_HOME}, $username);
	my $hash = $payload->{hash};
	die "Invalid hash: $hash" unless $hash =~ $safe_hash_regex;
	my $tmpfile = tempfile(UNLINK => 0);
	chmod(0644, $tmpfile);
	git_init($payload);
	chdir $repo or die "Cannot change directory: $repo ($!)";
	system('git', 'archive', '--format=tar.gz', '-o', $tmpfile, $hash) == 0
		or die "Failed to extract archive from hash: $hash ($!)";
	return $tmpfile->to_string;
}

my %allowed_commands = (
	write_blob			=> \&write_blob,
	update_file			=> \&update_file,
	rename_file			=> \&rename_file,
	delete_file			=> \&delete_file,
	backup_file			=> \&backup_file,
	git_commit			=> \&git_commit,
	git_log				=> \&git_log,
	git_show			=> \&git_show,
	git_checkout		=> \&git_checkout,
	git_archive			=> \&git_archive,
	provision_cert		=> \&provision_cert,
	update_domain_list	=> \&update_domain_list,
);

my $decoder = Sereal::Decoder->new;
my $encoder = Sereal::Encoder->new;

sub handle_conn {
	my $conn = shift;

	my $req_blob;
	while (read($conn, my $buf, 512)) {
		$req_blob .= $buf;
	}

	my $data = $decoder->decode($req_blob);
	my $command = $data->{command};
	my $payload = $data->{payload};

	my ($res, $err);

	eval {
		my $username = $payload->{username};

		unless ($username eq 'root') {
			my ($uid, $gid) = get_uid_gid($username);

			setgid($gid) or die "Cannot set group: $gid ($!)";
			setuid($uid) or die "Cannot set user: $uid ($!)";

			if ($has_unveil) {
				my $root = path($ENV{BLIPTOWN_USER_HOME}, $username);
				$root = $root->realpath;
				my @r_paths = ('/etc/gitignore');
				my @rwc_paths = ($root);
				unveil(\@r_paths, "r");
				unveil(\@rwc_paths, "rwc");
				unveil();
			}
		}

		my $func = $allowed_commands{$command} or
			die "Command not permitted: $command";

		$res = $func->($payload);
		delete_empty_dirs($username);
	};
	$err = $@;

	my $res_blob = $encoder->encode(
		{
			response => $res,
			error => $err,
		});

	$conn->send($res_blob) or warn "Cannot send response ($!)";
	return;
}

$SIG{CHLD} = sub { $needs_reap = 1 };
$SIG{TERM} = $SIG{INT} = sub { $shutdown = 1 };

sub spawn_worker {
	my $pid = fork();
	die "Cannot fork process ($!)" unless defined $pid;

	if ($pid == 0) {
		$0 =~ s/master/worker/;
		my $conn = $sock->accept();

		if (!$conn) {
			next if $!{EINTR} && !$shutdown;
			print "Worker $$ shutting down gracefully...\n";
			exit 0;
		}

		handle_conn $conn;
		close $conn;
		exit 0;
	}

	$children{$pid} = 1;
}

sub reap_children {
	while ((my $pid = waitpid -1, WNOHANG) > 0) {
		delete $children{$pid};
	}
}

while (1) {
	if ($needs_reap) {
		reap_children();
		$needs_reap = 0;
	}

	if ($shutdown) {
		kill('TERM', keys %children);
		last;
	}

	while (keys %children < $prefork && !$shutdown) {
		spawn_worker;
	}

	my $ok = kill(0, keys %children);
	$health_file->spew($ok);

	while (!$needs_reap && !$shutdown) { pause() }
}

while (%children) {
	reap_children();
	sleep 1;
}

print "Helper $$ exiting cleanly...\n";
exit 0;
